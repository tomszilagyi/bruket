#!/usr/bin/env escript
%% -*- erlang -*-

-mode(compile).

-define(GENDER_LIST, ["en", "ett", "pl."]).
-define(DRILL_LIST, [meaning, gender]).
-define(INITIAL_WEIGHT, 1).

-record(word, { type    :: noun | verb | adverb | adjective | other
                %% type-dependent, eg. gender for nouns, declension
                %% group for verbs, etc.
              , subtype :: atom()
              , forms   :: [string()] % forms to write the word
              , trans   :: [string()] % translations
              }).

-record(entry, { q     :: string()   % problem/question
               , a     :: string()   % correct answer
                 %% list of possible (including incorrect) answers, or a
                 %% function that generates them.
               , all_a :: [string()] | function()
               }).

main(_Args) ->
    io:setopts([{encoding, unicode}]),
    random:seed(erlang:now()),
    Words = words(),
    Drills0 = [{DType, entries(DType, Words)} || DType <- ?DRILL_LIST],
    Drills = [{DType, length(Entries), Entries} || {DType, Entries} <- Drills0,
                                                   Entries =/= []],
    DrillNames = [{DType, drill_caption(DType, N)} || {DType, N, _} <- Drills],
    {DrillType, _} = prompt("What to practice?", DrillNames),
    Entries = entries(DrillType, Words),
    drill(Entries).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Parser
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

words() ->
    words(filelib:wildcard("*.txt")).

words(FileList) ->
    lists:foldl(fun(Filename, Acc) -> parse(Filename, Acc) end, [], FileList).

parse(Filename, AccIn) ->
    [TypeStr | _] = string:tokens(Filename, "."),
    Type = list_to_atom(TypeStr),
    {ok, IoDev} = file:open(Filename, [read, binary, {encoding, utf8}]),
    Bin = io:get_chars(IoDev, "", filelib:file_size(Filename)),
    file:close(IoDev),
    Chars = unicode:characters_to_list(Bin, unicode),
    Lines = string:tokens(Chars, "\n"),
    NumberedLines = lists:zip(lists:seq(1, length(Lines)), Lines),
    lists:foldl(fun({Num, Line}, Acc) ->
                        try [parse_line(Type, Line) | Acc]
                        catch _:_ ->
                            io:format("~p: skipping line ~B: ~p~n",
                                      [Type, Num, Line]),
                            Acc
                        end
                end,
                AccIn, NumberedLines).

parse_line(Type, Line) ->
    %% Largest chunk of whitespace separates forms from translations
    {Forms, Trans} = split_blank(Line),
    parse_entry(Type, tokenize_csv(Forms), tokenize_csv(Trans)).

%% This can be split into multiple clauses based on Type.
%% Eg. for nouns, 2nd form contains gender (subtype) by convention.
parse_entry(Type, Forms, Trans) ->
    #word{type=Type, forms=Forms, trans=Trans}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Drills
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

drill_caption(meaning, N) ->
    io_lib:format("(~B)\tThe meaning of words", [N]);
drill_caption(gender, N) ->
    io_lib:format("(~B)\tGrammatical gender of nouns", [N]).

entries(meaning, Words) ->
    [mk_entry(meaning, W, Words) || W <- Words];
entries(gender, Words) ->
    [mk_entry(gender, W, Words) || #word{type=noun} = W <- Words].

%% Recognize the meaning of words
mk_entry(meaning, #word{type=Type, forms=Forms, trans=Trans}, Words) ->
    GoodAnswer = string:join(Trans, ", "),
    AllAnswers = [string:join(Wo#word.trans, ", ") ||
                     Wo <- Words, Wo#word.type =:= Type],
    #entry{q=string:join(Forms, ", "),
           a=GoodAnswer,
           all_a=mk_choose_answers(GoodAnswer, AllAnswers)};
%% Know the gender of nouns
mk_entry(gender, #word{forms=[Noun, Gender | _]}, _Words) ->
    AllAnswers = ?GENDER_LIST,
    #entry{q=Noun,
           a=Gender,
           all_a=AllAnswers}.

drill(Entries) ->
    %% Each entry in the list must be present the number of times
    %% according to its weight. So for the initial setup, replicate
    %% everything INITIAL_WEIGHT times.
    RepEntries = lists:flatten(lists:duplicate(?INITIAL_WEIGHT, [Entries])),
    do_drill(shuffle(RepEntries)).

do_drill([])                     -> finished;
do_drill([Entry|Rest] = Entries) ->
    NRem = length(Entries),
    case ask(Entry, NRem) of
        correct -> do_drill(Rest);
        faulty  -> do_drill(shuffle([Entry|Entries]))
    end.

ask(#entry{q=Q, a=GoodA, all_a=AllAnswers}, NRem) ->
    Options = case is_function(AllAnswers) of
                  true  -> AllAnswers();
                  false -> AllAnswers
              end,
    case prompt(Q, Options, NRem) of
        GoodA -> correct;
        _     -> io:format("Correct answer: ~s~n", [GoodA]),
                 faulty
    end.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Utility functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Shuffle a list like you would shuffle a deck of cards.
shuffle([])     -> [];
shuffle([A])    -> [A];
shuffle([A, B]) -> [B, A];
shuffle(L)      -> shuffle(L, length(L), length(L)).

shuffle(L, 0, _Len) -> L;
shuffle(L, N, Len)  ->
    I = random:uniform(Len-1),
    {La, [E|Lb]} = lists:split(I, L),
    shuffle([E|La]++lists:reverse(Lb), N-1, Len).

%% Randomly choose one element of L that is not present in Exceptions.
%% Note that exception items may be present in L multiple times.
choose([], _)         -> throw(choose_impossible);
choose(L, Exceptions) ->
    E = lists:nth(random:uniform(length(L)), L),
    case lists:member(E, Exceptions) of
        true  -> choose(L--Exceptions, Exceptions);
        false -> E
    end.

%% Present the user with a question and a list of answers and let them choose
%% one of the answers. The chosen answer will be the return value.
prompt(Question, Answers) ->
    io:format("~n~ts~n", [Question]),
    do_prompt(Answers).

prompt(Question, Answers, NRem) ->
    io:format("~nQ.~B: ~ts~n", [NRem, Question]),
    do_prompt(Answers).

do_prompt(Answers) ->
    N = length(Answers),
    NumberedAnswers = lists:zip(lists:seq(1, N), Answers),
    lists:foreach(fun({Seq, {Prompt, Caption}}) ->
                          io:format("  ~B: ~ts\t~ts~n", [Seq, Prompt, Caption]);
                     ({Seq, Ans}) ->
                          io:format("  ~B: ~ts~n", [Seq, Ans])
                  end, NumberedAnswers),
    try
        [Ch,$\n] = io:get_line("> "),
        ChosenSeq = list_to_integer([Ch]),
        lists:nth(ChosenSeq, Answers)
    catch _:_ ->
            io:format("~nJust a number (1-~B), please!~n", [N]),
            do_prompt(Answers)
    end.

%% Split a line in two at the longest piece of internal whitespace.
split_blank(String) ->
    %% Split into a list of chunks represented as 2- tuples {N, Str}
    %% where N is number of whitespace chars followed by a string of
    %% non-whitespace characters Str.
    Chunks = split_chunks(string:strip(String), []),
    LongestWS = lists:max([Len || {Len, _Str} <- Chunks]),
    Pred = fun({Len, _Str}) -> Len < LongestWS end,
    PreChunks = lists:takewhile(Pred, Chunks),
    PostChunks = lists:dropwhile(Pred, Chunks),
    {chunks_to_string(PreChunks), chunks_to_string(PostChunks)}.

split_chunks([], Chunks)     -> lists:reverse(Chunks);
split_chunks(String, Chunks) ->
    PreWS = string:span(String, " \t"),
    Chunk0 = string:substr(String, PreWS+1),
    PostWS = string:cspan(Chunk0, " \t"),
    Chunk = string:substr(Chunk0, 1, PostWS),
    Rest = string:substr(Chunk0, PostWS+1),
    split_chunks(Rest, [{PreWS, Chunk} | Chunks]).

chunks_to_string(Chunks) ->
    string:join([Str || {_N, Str} <- Chunks], " ").

%% Tokenize a string containing comma-separated values. Return list of
%% tokens with whitespace removed.
tokenize_csv([])     -> throw(empty);
tokenize_csv(String) ->
    Toks = string:tokens(String, ","),
    [string:strip(T) || T <- Toks].

%% Return a function to generate answers.
mk_choose_answers(GoodAnswer, AllAnswers) ->
    fun() ->
            BadA1 = choose(AllAnswers, [GoodAnswer]),
            BadA2 = choose(AllAnswers, [GoodAnswer, BadA1]),
            shuffle([GoodAnswer, BadA1, BadA2])
    end.
